package main

import (
	"crypto/aes"
	"crypto/cipher"
	"encoding/base64"
	"fmt"
	"math/rand"
	"strings"
)

func generateKey(seedTime int64) []byte {
	random := rand.New(rand.NewSource(seedTime))

	key := make([]byte, 16)
	for i := 0; i < 4; i++ {
		val := random.Uint32()
		key[i*4+0] = byte(val >> 24)
		key[i*4+1] = byte(val >> 16)
		key[i*4+2] = byte(val >> 8)
		key[i*4+3] = byte(val)
	}

	return key
}

func Decrypt(cipherTextB64 string, key []byte) (string, error) {
	cipherText, err := base64.StdEncoding.DecodeString(cipherTextB64)
	if err != nil {
		return "", err
	}

	block, err := aes.NewCipher(key)
	if err != nil {
		return "", err
	}

	iv := []byte{0x1a, 0x2b, 0x3c, 0x4d, 0x5e, 0x6f, 0x70, 0x81, 0x92, 0xa3, 0xb4, 0xc5, 0xd6, 0xe7, 0xf8, 0x09}

	if len(cipherText)%aes.BlockSize != 0 {
		return "", fmt.Errorf("cipherText is not a multiple of block size")
	}

	mode := cipher.NewCBCDecrypter(block, iv)
	plainText := make([]byte, len(cipherText))
	mode.CryptBlocks(plainText, cipherText)

	plainText, err = unpad(plainText, block.BlockSize())
	if err != nil {
		return "", err
	}

	return string(plainText), nil
}

func unpad(src []byte, blockSize int) ([]byte, error) {
	if len(src) == 0 {
		return nil, fmt.Errorf("input is empty")
	}
	padding := int(src[len(src)-1])
	if padding > blockSize || padding == 0 {
		return nil, fmt.Errorf("invalid padding")
	}
	for _, v := range src[len(src)-padding:] {
		if int(v) != padding {
			return nil, fmt.Errorf("invalid padding")
		}
	}

	return src[:len(src)-padding], nil
}

func main() {
	var accessTime int64 = 1750829797065                               // ここにはレスポンスヘッダーのAccessTimeの値をはる
	var encryptedFlag = "yR3rbGg1InO5U/ADIKppOFkgHo26Z1HJMbhET51KeQ0=" // ここに暗号化されたフラグを貼り付け
	key := generateKey(accessTime)
	var placeholder = "flag{"
	for i := int64(1); i < 1000; i++ {
		decrypted, _ := Decrypt(encryptedFlag, key)

		if strings.Contains(decrypted, placeholder) {
			fmt.Println("Flag = " + decrypted)
			break
		}
		key = generateKey(accessTime + i)
	}
}
