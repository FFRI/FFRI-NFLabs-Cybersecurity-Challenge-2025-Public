# writeup
## TimeFliesに実装した機能概要
TimeFliesは以下の3つのページからなります。
1. /login
   
    認証用ページ。このページからログインした場合のみ/flagを見ることができる。認証情報はadmin.xmlに書いてある。
2. /search

    DB内に保存したメッセージを検索できるページ。SQLインジェクションの脆弱性がある。ここは認証無しでアクセスできる、
3. /flag

    adminとしてログインしている場合のみ閲覧可能なページ。アクセスするとAESで暗号化したフラグを表示する。暗号鍵が推測可能になっており、元のフラグを復号できる脆弱性がある。

## 解法
TimeFliesには以下の2つの脆弱性がある。

1. /searchページのSQLインジェクション
2. /flagにおけるフラグの暗号鍵が推測可能

上記2つの脆弱性を使って以下のようにフラグを取得する。

* 脆弱性1によってadmin.xmlを読みだすことでadminユーザの認証情報を窃取する。
* 暗号鍵を推測することでフラグを復号する。

この2つの項目の実施手順を以下では述べる。

### admin.xmlの読み出し。
adminユーザの認証情報はadmin.xmlに書いてあるので、/searchページの検索欄で以下の2つの文字列を順番に検索する。

1. `aaaa' or 1=1; CREATE table leak (content text);COPY leak from $$/app/admin.xml$$;-- -#`
2. `aaaa' UNION select '1', content from leak;-- -#`

1つ目の文字列はテーブルleakを作成して、そこにadmin.xmlの中身を読み込む。

2つ目はテーブルleakの中身を検索結果とともに表示する。

### フラグの復号
/utils/crypto.goに実装された以下の箇所に脆弱性がある。この関数はフラグ暗号化用の鍵を生成する関数である。

5行目のrand.Newはシードが同じであれば毎回同じ値を返す。さらに、ここでシードとして与えられているseedTimeはミリ秒までの現在時刻から生成しているため、ブルートフォースによる暗号鍵の推測が可能になる。

また、本問題のWebアプリケーションは、簡単のためアクセス時刻の`time.Now().UnixMilli()`をレスポンスヘッダーに追加して返すようにしている。ブルートフォース開始時のseedTimeの値として、それを利用してもらうように想定している。

```
func generateKey() []byte {
	delay := rand.Intn(1000)
	time.Sleep(time.Duration(delay) * time.Millisecond)
	var seedTime = time.Now().UnixMilli()
	fmt.Println(strconv.FormatInt(seedTime, 10))
	random := rand.New(rand.NewSource(seedTime))
```

実際にブルートフォースを行うコードはwriteup/solution.goとして実装した。
