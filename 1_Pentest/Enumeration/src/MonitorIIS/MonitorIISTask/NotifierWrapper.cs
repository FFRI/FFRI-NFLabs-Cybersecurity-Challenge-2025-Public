using System.Runtime.InteropServices;


namespace MonitorIISTask
{
    internal class NotifierWrapper : IDisposable
    {
        [DllImport("kernel32")]
        private static extern IntPtr LoadLibrary(string dllName);

        [DllImport("kernel32")]
        private static extern IntPtr GetProcAddress(IntPtr module, string functionName);

        [DllImport("kernel32")]
        private static extern bool FreeLibrary(IntPtr module);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        delegate void SendImpl(string message);

        private IntPtr _dllPtr;

        private SendImpl _send;

        public NotifierWrapper(string dllName, string functionName)
        {
            _dllPtr = LoadLibrary(dllName);
            if (_dllPtr == IntPtr.Zero)
                throw new Exception("Failed load dll.");

            _send = LoadFunction<SendImpl>(functionName);
        }

        protected T LoadFunction<T>(string functionName)
        {
            IntPtr functionPtr = GetProcAddress(_dllPtr, functionName);
            if (functionPtr == IntPtr.Zero)
                throw new Exception("function not found.");

            return (T)(object)Marshal.GetDelegateForFunctionPointer(functionPtr, typeof(T));

        }

        public void Send(string message)
        {
            _send(message);
        }

        public void Dispose()
        {
            FreeLibrary(_dllPtr);
        }
    }
}
